// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"
)

const createList = `-- name: CreateList :one
INSERT INTO lists(id, title, user_id) VALUES ($1, $2, $3) RETURNING id, title, user_id, created_at
`

type CreateListParams struct {
	ID     string
	Title  string
	UserID string
}

func (q *Queries) CreateList(ctx context.Context, arg CreateListParams) (List, error) {
	row := q.db.QueryRow(ctx, createList, arg.ID, arg.Title, arg.UserID)
	var i List
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const createTodo = `-- name: CreateTodo :one
INSERT INTO todos(id, text, list_id, user_id) VALUES ($1, $2, $3, $4) RETURNING id, text, completed, list_id, user_id, created_at
`

type CreateTodoParams struct {
	ID     string
	Text   string
	ListID string
	UserID string
}

func (q *Queries) CreateTodo(ctx context.Context, arg CreateTodoParams) (Todo, error) {
	row := q.db.QueryRow(ctx, createTodo,
		arg.ID,
		arg.Text,
		arg.ListID,
		arg.UserID,
	)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.Completed,
		&i.ListID,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users(id, username, password) VALUES ($1, $2, $3) RETURNING id, username, password, created_at
`

type CreateUserParams struct {
	ID       string
	Username string
	Password string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.ID, arg.Username, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const deleteList = `-- name: DeleteList :exec
DELETE FROM lists WHERE id = $1 AND user_id = $2
`

type DeleteListParams struct {
	ID     string
	UserID string
}

func (q *Queries) DeleteList(ctx context.Context, arg DeleteListParams) error {
	_, err := q.db.Exec(ctx, deleteList, arg.ID, arg.UserID)
	return err
}

const deleteTodo = `-- name: DeleteTodo :exec
DELETE FROM todos WHERE id = $1 AND list_id = $2 AND user_id = $3
`

type DeleteTodoParams struct {
	ID     string
	ListID string
	UserID string
}

func (q *Queries) DeleteTodo(ctx context.Context, arg DeleteTodoParams) error {
	_, err := q.db.Exec(ctx, deleteTodo, arg.ID, arg.ListID, arg.UserID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getList = `-- name: GetList :one
SELECT id, title, user_id, created_at FROM lists WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetListParams struct {
	ID     string
	UserID string
}

func (q *Queries) GetList(ctx context.Context, arg GetListParams) (List, error) {
	row := q.db.QueryRow(ctx, getList, arg.ID, arg.UserID)
	var i List
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getLists = `-- name: GetLists :many
SELECT id, title, user_id, created_at FROM lists WHERE user_id = $1
`

func (q *Queries) GetLists(ctx context.Context, userID string) ([]List, error) {
	rows, err := q.db.Query(ctx, getLists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodo = `-- name: GetTodo :one
SELECT id, text, completed, list_id, user_id, created_at FROM todos WHERE id = $1 AND list_id = $2 AND user_id = $3 LIMIT 1
`

type GetTodoParams struct {
	ID     string
	ListID string
	UserID string
}

func (q *Queries) GetTodo(ctx context.Context, arg GetTodoParams) (Todo, error) {
	row := q.db.QueryRow(ctx, getTodo, arg.ID, arg.ListID, arg.UserID)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.Completed,
		&i.ListID,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getTodos = `-- name: GetTodos :many
SELECT id, text, completed, list_id, user_id, created_at FROM todos WHERE user_id = $1 AND list_id = $2
`

type GetTodosParams struct {
	UserID string
	ListID string
}

func (q *Queries) GetTodos(ctx context.Context, arg GetTodosParams) ([]Todo, error) {
	rows, err := q.db.Query(ctx, getTodos, arg.UserID, arg.ListID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.Completed,
			&i.ListID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, username, password, created_at FROM users WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const updateList = `-- name: UpdateList :exec
UPDATE lists SET title = $2 WHERE id = $1 AND user_id = $3
`

type UpdateListParams struct {
	ID     string
	Title  string
	UserID string
}

func (q *Queries) UpdateList(ctx context.Context, arg UpdateListParams) error {
	_, err := q.db.Exec(ctx, updateList, arg.ID, arg.Title, arg.UserID)
	return err
}

const updateTodo = `-- name: UpdateTodo :exec
UPDATE todos SET text = $2, completed = $3 WHERE id = $1 AND list_id = $4 AND user_id = $5
`

type UpdateTodoParams struct {
	ID        string
	Text      string
	Completed bool
	ListID    string
	UserID    string
}

func (q *Queries) UpdateTodo(ctx context.Context, arg UpdateTodoParams) error {
	_, err := q.db.Exec(ctx, updateTodo,
		arg.ID,
		arg.Text,
		arg.Completed,
		arg.ListID,
		arg.UserID,
	)
	return err
}
